import React, { useCallback, useEffect, useReducer } from "react";
import { order, getSort } from "./utils/order-utils";
import { applyFilter, updateFilters, transformFilterPropToStateFilter, } from "./utils/filter-utils";
import { withPagination } from "./utils/pagination-utils";
import { listSuperReducer, getInitialState, ActionType, } from "./list-super-partials";
const ListSuper = ({ HeaderUnit, FilterUnit, OrderController, ColCell, GlobalSearch, NoRow, Row, ListWrapper, ListContainer, ListHeader, ListBody, RecordInfo, Pagination, Loader, }) => (props) => {
    const { def, config = {}, asyncData, CustomListContainer, CustomListItem, } = props;
    const filtersFromProps = config.filters
        ? transformFilterPropToStateFilter(def, config.filters)
        : undefined;
    const [state, dispatch] = useReducer(listSuperReducer, getInitialState(props.data, config.sortAttribute, config.sortDescAsc, filtersFromProps));
    const { filters, pageIdx, sortAttribute, sortDescAsc, data, numberOfTotalRows, loading, } = state;
    const nPerPage = config.nPerPage || props.nPerPage || 25;
    if (props.nPerPage) {
        console.warn("The use of nPerPage in props is deprecated. Add nPerPage to the config object prop.");
    }
    const fetchData = useCallback((config) => {
        if (asyncData) {
            dispatch({ type: ActionType.FETCH_DATA_REQUEST });
            asyncData({
                nPerPage,
                pageIdx: config && config.pageIdx ? config.pageIdx : pageIdx,
                filters: config && config.filters ? config.filters : filters,
                sort: {
                    attribute: config && config.sortAttribute
                        ? config.sortAttribute
                        : sortAttribute,
                    descAsc: config && typeof config.sortDescAsc !== "undefined"
                        ? config.sortDescAsc
                        : sortDescAsc,
                },
            }).then((res) => {
                dispatch({
                    type: ActionType.FETCH_DATA_SUCCESS,
                    payload: { data: res.data, numberOfTotalRows: res.meta.n },
                });
            });
        }
    }, [asyncData, filters, nPerPage, pageIdx, sortAttribute, sortDescAsc]);
    useEffect(() => {
        fetchData();
    }, [asyncData, fetchData]);
    useEffect(() => {
        const data = props.data;
        const numberOfTotalRows = data ? data.length : 0;
        dispatch({
            type: ActionType.FETCH_DATA_SUCCESS,
            payload: {
                data,
                numberOfTotalRows,
            },
        });
    }, [props.data]);
    const handleFilterChange = (v) => {
        const newFilters = updateFilters(filters, v);
        // when a filter is applied, the page index is reset
        const pageIdx = 1;
        const config = {
            filters: newFilters,
            pageIdx,
        };
        dispatch({
            type: ActionType.FILTER_CHANGE,
            payload: config,
        });
        fetchData(config);
    };
    const handleFilterReset = (name) => {
        const newFilters = Object.assign({}, filters);
        delete newFilters[name];
        // when a filter is applied, the page index is reset
        const pageIdx = 1;
        const config = {
            filters: newFilters,
            pageIdx,
        };
        dispatch({ type: ActionType.FILTER_CHANGE, payload: config });
        fetchData(config);
    };
    /**
     * defines order to apply
     * @param  {[type]} name    attribute/column
     * @param  {[type]} descAsc true/false - asc or desc. if null, will toggle
     * @return {[type]}         [description]
     * todo: allow custom ordering
     */
    const setOrder = (name, descAsc = null) => {
        if (descAsc === null) {
            descAsc = !sortDescAsc;
        }
        const config = { sortDescAsc: descAsc, sortAttribute: name, pageIdx: 1 };
        dispatch({
            type: ActionType.ORDER_CHANGE,
            payload: config,
        });
    };
    const changePage = (pageIdx) => {
        // todo block beyond max page
        if (pageIdx > 0) {
            const config = { pageIdx };
            dispatch({ type: ActionType.PAGE_CHANGE, payload: config });
        }
    };
    const isSort = (h) => {
        return ((typeof h.sort === "boolean" && h.sort === true) ||
            typeof h.sort === "object");
    };
    const renderHeaders = () => {
        return def.map((h, i) => {
            const order = isSort(h) ? (React.createElement(OrderController, { descAsc: sortAttribute === h.name ? sortDescAsc : null, onClick: () => setOrder(h.name) })) : null;
            const filter = (React.createElement(FilterUnit, { key: i, filters: filters, name: h.name, filter: h.filter, onChange: handleFilterChange, onReset: handleFilterReset, debounceWait: config.debounceWait }));
            return (React.createElement(HeaderUnit, { key: i },
                h.label || "",
                " ",
                order,
                " ",
                filter));
        });
    };
    const renderBody = (data) => {
        return data.map((row, i) => (React.createElement(React.Fragment, { key: i }, CustomListItem ? (React.createElement(React.Fragment, null, CustomListContainer ? (CustomListItem(row)) : (React.createElement(Row, null,
            React.createElement(ColCell, { colSpan: def.length, style: {
                    paddingLeft: 0,
                    paddingRight: 0,
                    borderBottom: 0,
                } }, CustomListItem(row)))))) : (React.createElement(Row, null, def.map((h, j) => (React.createElement(ColCell, { key: j }, h.render ? h.render(row) : React.createElement(React.Fragment, null, row[h.name])))))))));
    };
    const renderLoader = () => (React.createElement(Row, null,
        React.createElement(ColCell, { colSpan: def.length },
            React.createElement(Loader, null))));
    let fData = [];
    let fpData = [];
    let n = 0;
    if (!asyncData) {
        fData = applyFilter(data, filters);
        n = fData.length;
        fpData = sortAttribute
            ? withPagination(order(fData, getSort(def, sortAttribute), sortDescAsc), pageIdx, nPerPage)
            : withPagination(fData, pageIdx, nPerPage);
    }
    else {
        n = numberOfTotalRows;
    }
    const showPagination = typeof config.pagination !== "undefined" ? config.pagination : true;
    const showRecordInfo = typeof config.recordInfo !== "undefined" ? config.recordInfo : true;
    return (React.createElement(ListWrapper, null,
        React.createElement(GlobalSearch, { search: config.search, onChange: handleFilterChange, filters: filters, debounceWait: config.debounceWait }),
        CustomListContainer ? (React.createElement(React.Fragment, null,
            React.createElement(ListContainer, null,
                React.createElement(ListHeader, null,
                    React.createElement(Row, null, renderHeaders()))),
            CustomListContainer(renderBody(asyncData ? data : fpData)))) : (React.createElement(ListContainer, { maxHeight: config.maxHeight, stickyHeader: config.stickyHeader },
            React.createElement(ListHeader, null,
                React.createElement(Row, null, renderHeaders())),
            React.createElement(ListBody, null, loading ? renderLoader() : renderBody(asyncData ? data : fpData)))),
        showRecordInfo && (React.createElement(RecordInfo, { n: n, idx: pageIdx, nPerPage: nPerPage })),
        showPagination && n > nPerPage && (React.createElement(Pagination, { n: n, nPerPage: nPerPage, idx: pageIdx, onClick: changePage })),
        !loading && React.createElement(NoRow, { n: n })));
};
export default ListSuper;
